# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Mean shift clustering
#' @title Mean shift clustering
#' @description
#' Adaptive mean shift clustering to delineate tree crowns from lidar point clouds
#' @param pc Point cloud has to be in matrix format with 3-columns representing X, Y and Z and each row representing one point
#' @param H2CW_fac Factor for the ratio of height to crown width. Determines kernel diameter based on its height above ground.
#' @param H2CL_fac Factor for the ratio of height to crown length. Determines kernel height based on its height above ground.
#' @param UniformKernel Boolean to enable the application of a simple uniform kernel without distance weighting (Default False)
#' @param MaxIter Maximum number of iterations, i.e. steps that the kernel can move for each point. If centroid is not found after all iteration, the last position is assigned as centroid and the processing jumps to the next point
#' @param minz Minimum height above ground for a point to be considered in the analysis. Has to be > 0.
#' @param ctr.ac Centroid accuracy. Specifies the rounding accuracy for centroid positions. After rounding all centroids with the same coordinates are considered to belong to one tree crown.
#' @return data.frame with X, Y and Z coordinates of each point in the point cloud and  X, Y and Z coordinates of the centroid to which the point belongs
#' @import Rcpp
#' @export
MeanShift_Classical <- function(pc, H2CW_fac, H2CL_fac, UniformKernel = FALSE, MaxIter = 20L, minz = 2, ctr.ac = 2, maxIntensity=65535, spectralImportance = 1, spatialImportance = 1, clustDist = 2) {
  pre_processing_res = pre_process(pc, minz)
  my.minx = pre_processing_res[["my.minx"]]
  my.miny = pre_processing_res[["my.miny"]]
  my.mx = pre_processing_res[["my.mx"]]

  result.df = C_MeanShift_Classical(my.mx, H2CW_fac, H2CL_fac, UniformKernel, MaxIter, maxIntensity, spectralImportance, spatialImportance, clustDist)
  return(data.table::as.data.table(result.df))
}


#' Mean shift clustering using a discrete voxel space
#'
#' @title Mean shift clustering using a discrete voxel space
#' @description
#' Adaptive mean shift clustering to delineate tree crowns from lidar point clouds. This is a version using 1-mÂ³ voxels instead of exact point coordinates, to speed up processing.
#' @param pc Point cloud has to be in matrix format with 3-columns representing X, Y and Z and each row representing one point
#' @param H2CW_fac Factor for the ratio of height to crown width. Determines kernel diameter based on its height above ground.
#' @param H2CL_fac Factor for the ratio of height to crown length. Determines kernel height based on its height above ground.
#' @param UniformKernel Boolean to enable the application of a simple uniform kernel without distance weighting (Default False)
#' @param MaxIter Maximum number of iterations, i.e. steps that the kernel can move for each point. If centroid is not found after all iteration, the last position is assigned as centroid and the processing jumps to the next point
#' @param minz Minimum height above ground for a point to be considered in the analysis. Has to be > 0.
#' @param ctr.ac Centroid accuracy. Specifies the rounding accuracy for centroid positions. After rounding all centroids with the same coordinates are considered to belong to one tree crown.
#' @return data.frame with X, Y and Z coordinates of each point in the point cloud and  X, Y and Z coordinates of the centroid to which the point belongs
#' @export
MeanShift_Voxels <- function(pc, H2CW_fac, H2CL_fac, UniformKernel = FALSE, MaxIter = 20L, minz=2, ctr.ac=2) {
  pre_processing_res = pre_process(pc, minz)
  my.minx = pre_processing_res[["my.minx"]]
  my.miny = pre_processing_res[["my.miny"]]
  my.mx = pre_processing_res[["my.mx"]]

  result.df = C_MeanShift_Voxels(pc=my.mx, H2CW_fac=H2CW_fac, H2CL_fac=H2CL_fac, UniformKernel, MaxIter=MaxIter, maxx=pre_processing_res[["maxx"]], maxy=pre_processing_res[["maxy"]], maxz=pre_processing_res[["maxz"]])

  result.dt = post_process(result.df, ctr.ac, my.minx, my.miny)
  return(result.dt)
}

#' @import data.table
pre_process = function(pc, minz) {
  requireNamespace("data.table")

  # Add data.table operator
  `:=` <- data.table::`:=`

  X = Y = Z = NA

  my.dt = data.table::data.table(pc)
  my.dt[,id := .I]
  my.dt = my.dt[Z >= minz]

  # Get margins
  my.minx <- floor(min(my.dt$X))
  my.maxx <- ceiling(max(my.dt$X))
  my.miny <- floor(min(my.dt$Y))
  my.maxy <- ceiling(max(my.dt$Y))
  my.rangex <- my.maxx - my.minx
  my.rangey <- my.maxy - my.miny
  my.maxz <- ceiling(max(my.dt$Z))

  # Get margins of the core area
  core.minx <- floor(min(my.dt[, X]))
  core.maxx <- ceiling(max(my.dt[, X]))
  core.miny <- floor(min(my.dt[, Y]))
  core.maxy <- ceiling(max(my.dt[, Y]))

  # Shift to coordinate origin
  my.dt[, X := X - my.minx]
  my.dt[, Y := Y - my.miny]

  # Convert to 3-column matrix
  data.table::setcolorder(my.dt, "id")
  my.mx <- as.matrix(my.dt)

  return (list(my.mx = my.mx, my.minx = my.minx, my.miny = my.miny, maxx=my.rangex, maxy=my.rangey, maxz=my.maxz))
}


post_process = function(result.df, ctr.ac, my.minx, my.miny)
{
  requireNamespace("data.table")
  # Add data.table operator
  `:=` <- data.table::`:=`

  RoundCtrX = CtrX = RoundCtrY =
  CtrY = RoundCtrZ = CtrZ = X =
  Y = ID = NA

  # Round the centroid coordinates
  result.dt <- data.table(result.df)
  result.dt[, RoundCtrX := plyr::round_any(CtrX, accuracy=ctr.ac)]
  result.dt[, RoundCtrY := plyr::round_any(CtrY, accuracy=ctr.ac)]
  result.dt[, RoundCtrZ := plyr::round_any(CtrZ, accuracy=ctr.ac)]

  # Shift back to original positions
  result.dt[, X := X + my.minx]
  result.dt[, Y := Y + my.miny]
  result.dt[, CtrX := CtrX + my.minx]
  result.dt[, CtrY := CtrY + my.miny]
  result.dt[, RoundCtrX := RoundCtrX + my.minx]
  result.dt[, RoundCtrY := RoundCtrY + my.miny]

  result.dt[ , ID := .GRP, by = .(RoundCtrX, RoundCtrY, RoundCtrZ)]
}
